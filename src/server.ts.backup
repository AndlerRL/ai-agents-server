/**
 * AI Agents Server - Proper Integration with RAG System
 * Using Bun's native serve with Elysia routes integration
 * Includes client build system and comprehensive RAG capabilities
 */

import { existsSync, readFileSync } from 'node:fs'
import { join } from 'node:path'
import type { Server, ServerWebSocket } from 'bun'
import { serve } from 'bun'
import { Elysia } from 'elysia'
import { cors } from '@elysiajs/cors'
import { swagger } from '@elysiajs/swagger'

import { buildClient } from './lib/build-client'
import { createSwaggerConfig } from './lib/swagger-config'
import { createAIAgentsState } from './core/elysia-state'
import type { ServerConfig } from './core/types'
import { bootstrapRagSystemWithValidation } from './rag'
import type { MainRagService } from './rag'

// ============================================================================
// Server Configuration
// ============================================================================

const config: ServerConfig = {
  environment: (process.env.NODE_ENV as 'development' | 'production') || 'development',
  port: parseInt(process.env.PORT || '3001'),
  
  openai: {
    apiKey: process.env.OPENAI_API_KEY || '',
    baseURL: process.env.OPENAI_BASE_URL,
    organization: process.env.OPENAI_ORGANIZATION
  },
  
  memory: {
    provider: 'memory',
    maxSize: 100000,
    ttl: 3600
  },
  
  chunking: {
    strategy: 'semantic',
    chunkSize: 1000,
    overlap: 200
  }
}

// ============================================================================
// Client Build Helper
// ============================================================================

function getClientFilename(): string {
  try {
    const manifestPath = join(process.cwd(), 'public', 'manifest.json')
    if (existsSync(manifestPath)) {
      const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'))
      return manifest.clientJs || 'client.js'
    }
  } catch (error) {
    console.error('Error reading manifest:', error)
  }
  return 'client.js'
}

// ============================================================================
// Elysia App with Routes
// ============================================================================

const app = new Elysia()
  .use(cors())
  .use(swagger(createSwaggerConfig(config)))
  .use(createAIAgentsState(config))
  
  // Dashboard - Main page with API statistics
  .get('/', async ({ getServerStats }: any) => {
    const stats = getServerStats()
    
    // Get RAG system health if available
    let ragHealth = null
    if (ragService) {
      try {
        ragHealth = await ragService.healthCheck()
      } catch (error) {
        ragHealth = { status: 'unhealthy', error: 'Health check failed' }
      }
    }
    
    return {
      title: 'AI Agents Server Dashboard',
      description: 'Real-time API usage statistics and server monitoring with RAG capabilities',
      version: '1.0.0',
      uptime: Math.floor(stats.uptime || 0),
      statistics: {
        totalRequests: stats.requests || 0,
        activeAgents: stats.agents || 0,
        totalTokensUsed: stats.tokensUsed || 0,
        averageResponseTime: stats.averageResponseTime || 0,
        errorRate: stats.errorRate || 0,
        activeConnections: stats.connections || 0,
        webhookSubscriptions: 0 // This would come from webhook manager
      },
      health: {
        status: 'healthy',
        openaiEnabled: stats.features?.openaiEnabled || false,
        ragEnabled: !!ragService,
        ragStatus: ragHealth?.status || 'disabled',
        debugMode: stats.features?.debugMode || false,
        lastUpdate: new Date().toISOString()
      },
      endpoints: {
        api: '/api',
        docs: '/docs',
        openai: '/v1/openai/*',
        ai: '/v1/ai/*',
        rag: '/v1/rag/*',
        database: '/v1/database/*',
        webhooks: '/webhooks/ws'
      },
      ragSystem: ragService ? {
        enabled: true,
        status: ragHealth?.status || 'unknown',
        dualDatabase: {
          postgresql: {
            enabled: true,
            status: 'healthy',
            features: ['pgvector', 'semantic_search', 'traditional_queries']
          },
          neo4j: {
            enabled: true,
            status: 'healthy', 
            features: ['graph_traversal', 'relationship_analysis', 'centrality_metrics']
          },
          router: {
            enabled: true,
            strategies: ['vector_first', 'graph_first', 'adaptive'],
            activeStrategy: 'adaptive'
          }
        },
        strategies: [
          'retrieve_read',
          'hybrid', 
          'two_stage_rerank',
          'fusion_in_decoder',
          'augmented_reranking',
          'federated',
          'graph_rag',
          'adaptive'
        ]
      } : {
        enabled: false,
        reason: 'RAG system not initialized - check DATABASE_URL and dependencies'
      }
    }
  }, {
    detail: {
      tags: ['Introduction'],
      summary: 'Server dashboard',
      description: 'Real-time dashboard with API usage statistics, server health, RAG system status, and endpoint information'
    }
  })
  
  // API Information endpoint
  .get('/api', () => ({
    title: 'AI Agents Server API',
    description: 'Sophisticated agentic AI server using ElysiaJS, OpenAI, Vercel AI SDK, and RAG systems',
    version: '1.0.0',
    endpoints: {
      openai: '/v1/openai/*',
      ai: '/v1/ai/*',
      rag: '/v1/rag/*',
      database: '/v1/database/*',
      webhooks: '/webhooks/ws',
      docs: '/docs'
    },
    capabilities: [
      'OpenAI agent integration',
      'Vercel AI SDK streaming',
      'Dual-database RAG architecture (PostgreSQL + Neo4j)',
      'Intelligent database routing and query optimization',
      'Graph-enhanced semantic search',
      'Real-time database synchronization',
      'Advanced graph analytics and relationship traversal',
      'Adaptive retrieval strategies',
      'Real-time WebSocket events',
      'pgvector and Neo4j native support'
    ]
  }), {
    detail: {
      tags: ['Introduction'],
      summary: 'API information',
      description: 'Get API server information, available endpoints, and system capabilities'
    }
  })
  
  // OpenAI Agent routes - /v1/openai/*
  .group('/v1/openai', (app) => app
    .get('/', () => ({
      title: 'OpenAI Agents API',
      description: 'OpenAI agent integration with chat completions and tool calling',
      version: '1.0.0',
      endpoints: {
        agents: '/v1/openai/agents',
        chat: '/v1/openai/chat',
        models: '/v1/openai/models',
        tools: '/v1/openai/tools'
      }
    }), {
      detail: {
        tags: ['OpenAI Agents'],
        summary: 'OpenAI API information',
        description: 'Get OpenAI agent integration information and available endpoints'
      }
    })
    
    // Agent management
    .group('/agents', (app) => app
      .get('/', ({ getAllAgents }: any) => {
        return {
          success: true,
          data: getAllAgents()
        }
      }, {
        detail: {
          tags: ['OpenAI Agents'],
          summary: 'List all OpenAI agents',
          description: 'Retrieve all OpenAI agents with their current status and configuration'
        }
      })
      
      .post('/', async ({ body, createAgent, incrementAgents }: any) => {
        try {
          const agent = await createAgent(body)
          incrementAgents()
          return {
            success: true,
            data: agent
          }
        } catch (error) {
          return {
            success: false,
            error: 'Failed to create agent',
            message: String(error)
          }
        }
      }, {
        detail: {
          tags: ['OpenAI Agents'],
          summary: 'Create new OpenAI agent',
          description: 'Create a new OpenAI agent with specified configuration',
          body: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Agent name' },
              model: { type: 'string', default: 'gpt-4o-mini' },
              tools: { type: 'array', items: { type: 'string' } },
              config: { type: 'object' }
            },
            required: ['name']
          }
        }
      })
    )
    
    // Chat completions
    .group('/chat', (app) => app
      .post('/completions', async ({ body, chatWithAgent, addTokenUsage }: any) => {
        try {
          const { model = 'gpt-4o-mini', messages, ...options } = body
          
          const response = await chatWithAgent(model, messages, options)
          addTokenUsage(response.metadata.tokensUsed)
          
          return {
            success: true,
            data: response
          }
        } catch (error) {
          return {
            success: false,
            error: 'Chat completion failed',
            message: String(error)
          }
        }
      }, {
        detail: {
          tags: ['OpenAI Agents'],
          summary: 'OpenAI chat completion',
          description: 'Generate chat completions using OpenAI models with agent context',
          body: {
            $ref: '#/components/schemas/ChatRequest'
          }
        }
      })
    )
  )
  
  // Custom AI Agent routes - /v1/ai/*
  .group('/v1/ai', (app) => app
    .get('/', () => ({
      title: 'Custom AI Agents API',
      description: 'Custom AI agent server using Vercel AI SDK',
      version: '1.0.0',
      endpoints: {
        agents: '/v1/ai/agents',
        chat: '/v1/ai/chat',
        stream: '/v1/ai/stream'
      }
    }), {
      detail: {
        tags: ['Custom AI'],
        summary: 'Custom AI API information',
        description: 'Get custom AI agent integration information using Vercel AI SDK'
      }
    })
    
    .group('/chat', (app) => app
      .post('/stream', async ({ body, chatWithAgent }: any) => {
        try {
          const { model = 'gpt-4o-mini', messages, stream = true } = body
          
          if (stream) {
            const response = await chatWithAgent(model, messages, { stream: true })
            return new Response(response.stream, {
              headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
              }
            })
          } else {
            const response = await chatWithAgent(model, messages, { stream: false })
            return {
              success: true,
              data: response
            }
          }
        } catch (error) {
          return {
            success: false,
            error: 'AI chat failed',
            message: String(error)
          }
        }
      }, {
        detail: {
          tags: ['Custom AI'],
          summary: 'Streaming AI chat',
          description: 'Generate streaming chat responses using Vercel AI SDK with real-time token streaming',
          body: {
            type: 'object',
            properties: {
              model: { type: 'string', default: 'gpt-4o-mini' },
              messages: {
                type: 'array',
                items: { $ref: '#/components/schemas/ChatMessage' }
              },
              stream: { type: 'boolean', default: true, description: 'Enable streaming response' },
              temperature: { type: 'number', minimum: 0, maximum: 2 },
              maxTokens: { type: 'integer', minimum: 1 }
            },
            required: ['messages']
          }
        }
      })
    )
  )

// ============================================================================
// RAG System Integration
// ============================================================================

// Initialize RAG system
let ragService: MainRagService

// Add RAG routes
app.group('/v1/rag', (app) => app
  .get('/', () => ({
    title: 'Dual-Database RAG System API',
    description: 'Advanced Retrieval-Augmented Generation with PostgreSQL + pgvector and Neo4j dual-database architecture',
    version: '1.0.0',
    architecture: {
      databases: {
        postgresql: {
          role: 'Primary vector database',
          features: ['pgvector', 'semantic_search', 'traditional_queries', 'dual_schema_support'],
          schemas: ['public', 'graph_public']
        },
        neo4j: {
          role: 'Graph relationship database', 
          features: ['graph_traversal', 'relationship_analysis', 'centrality_metrics', 'community_detection']
        }
      },
      routing: {
        intelligent_routing: 'Automatic database selection based on query characteristics',
        strategies: ['vector_first', 'graph_first', 'adaptive'],
        performance_optimization: 'Query-specific database routing for optimal performance'
      }
    },
    endpoints: {
      retrieve: '/v1/rag/retrieve',
      documents: '/v1/rag/documents',
      health: '/v1/rag/health',
      metrics: '/v1/rag/metrics',
      database_status: '/v1/database/status',
      routing_info: '/v1/database/router'
    },
    strategies: [
      'retrieve_read',
      'hybrid',
      'two_stage_rerank', 
      'fusion_in_decoder',
      'augmented_reranking',
      'federated',
      'graph_rag',
      'adaptive'
    ]
  }), {
    detail: {
      tags: ['RAG System'],
      summary: 'Dual-database RAG API information',
      description: 'Get comprehensive information about the dual-database RAG system architecture and capabilities'
    }
  })

  // Main retrieval endpoint
  .post('/retrieve', async ({ body }: any) => {
    try {
      if (!ragService) {
        return {
          success: false,
          error: 'RAG system not initialized',
          message: 'RAG service is not available'
        }
      }

      const { query, strategy, topK, granularity, includeMetadata, filters } = body
      
      if (!query) {
        return {
          success: false,
          error: 'Missing query',
          message: 'Query text is required'
        }
      }

      const ragQuery = {
        text: query,
        strategy,
        topK: topK || 5,
        granularity: granularity || 'coarse',
        includeMetadata: includeMetadata || false,
        filters,
        queryId: crypto.randomUUID(),
        clientId: 'web-client',
        metadata: {
          requestId: crypto.randomUUID(),
          timestamp: new Date().toISOString()
        }
      }

      const response = await ragService.retrieve(ragQuery)

      return {
        success: true,
        data: response
      }
    } catch (error) {
      console.error('RAG retrieval error:', error)
      return {
        success: false,
        error: 'RAG retrieval failed',
        message: String(error)
      }
    }
  }, {
    detail: {
      tags: ['RAG System'],
      summary: 'Retrieve documents',
      description: 'Retrieve relevant documents using RAG system with various strategies',
      body: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query text' },
          strategy: { 
            type: 'string', 
            enum: ['retrieve_read', 'hybrid', 'two_stage_rerank', 'fusion_in_decoder', 'augmented_reranking', 'federated', 'graph_rag', 'adaptive'],
            description: 'Retrieval strategy to use'
          },
          topK: { type: 'integer', minimum: 1, maximum: 50, default: 5, description: 'Number of results to return' },
          granularity: { type: 'string', enum: ['coarse', 'fine', 'adaptive'], default: 'coarse', description: 'Chunk granularity' },
          includeMetadata: { type: 'boolean', default: false, description: 'Include additional metadata' },
          filters: {
            type: 'object',
            properties: {
              dateRange: {
                type: 'object',
                properties: {
                  start: { type: 'string', format: 'date-time' },
                  end: { type: 'string', format: 'date-time' }
                }
              },
              sources: { type: 'array', items: { type: 'string' } },
              contentTypes: { type: 'array', items: { type: 'string' } },
              languages: { type: 'array', items: { type: 'string' } }
            }
          }
        },
        required: ['query']
      }
    }
  })

  // Adaptive retrieval
  .post('/adaptive', async ({ body }: any) => {
    try {
      if (!ragService) {
        return {
          success: false,
          error: 'RAG system not initialized'
        }
      }

      const { query, topK, includeMetadata } = body
      
      const ragQuery = {
        text: query,
        topK: topK || 5,
        granularity: 'adaptive' as const,
        includeMetadata: includeMetadata || false,
        queryId: crypto.randomUUID(),
        clientId: 'web-client'
      }

      const response = await ragService.adaptiveRetrieve(ragQuery)

      return {
        success: true,
        data: response,
        explanation: 'Used adaptive strategy selection based on query characteristics'
      }
    } catch (error) {
      return {
        success: false,
        error: 'Adaptive retrieval failed',
        message: String(error)
      }
    }
  }, {
    detail: {
      tags: ['RAG System'],
      summary: 'Adaptive retrieval',
      description: 'Automatically select optimal retrieval strategy based on query characteristics'
    }
  })

  // Document management
  .group('/documents', (app) => app
    .post('/', async ({ body }: any) => {
      try {
        if (!ragService) {
          return { success: false, error: 'RAG system not initialized' }
        }

        const { content, metadata } = body
        const documentId = await ragService.addDocument(content, metadata)

        return {
          success: true,
          data: { documentId },
          message: 'Document added successfully'
        }
      } catch (error) {
        return {
          success: false,
          error: 'Failed to add document',
          message: String(error)
        }
      }
    }, {
      detail: {
        tags: ['RAG System'],
        summary: 'Add document',
        description: 'Add a new document to the RAG system'
      }
    })

    .post('/batch', async ({ body }: any) => {
      try {
        if (!ragService) {
          return { success: false, error: 'RAG system not initialized' }
        }

        const { documents } = body
        const documentIds = await ragService.addDocuments(documents)

        return {
          success: true,
          data: { documentIds },
          message: `Added ${documentIds.length} documents`
        }
      } catch (error) {
        return {
          success: false,
          error: 'Failed to add documents',
          message: String(error)
        }
      }
    })

    .delete('/:id', async ({ params }: any) => {
      try {
        if (!ragService) {
          return { success: false, error: 'RAG system not initialized' }
        }

        await ragService.deleteDocument(params.id)

        return {
          success: true,
          message: 'Document deleted successfully'
        }
      } catch (error) {
        return {
          success: false,
          error: 'Failed to delete document',
          message: String(error)
        }
      }
    })
  )

  // Health and metrics
  .get('/health', async () => {
    try {
      if (!ragService) {
        return {
          status: 'unhealthy',
          error: 'RAG system not initialized'
        }
      }

      const health = await ragService.healthCheck()
      return health
    } catch (error) {
      return {
        status: 'unhealthy',
        error: 'Health check failed',
        message: String(error)
      }
    }
  }, {
    detail: {
      tags: ['RAG System'],
      summary: 'Health check',
      description: 'Check RAG system health status'
    }
  })

  .get('/metrics', async () => {
    try {
      if (!ragService) {
        return { error: 'RAG system not initialized' }
      }

      const [systemMetrics, indexStats] = await Promise.all([
        ragService.getSystemMetrics(),
        ragService.getIndexStats()
      ])

      return {
        success: true,
        data: {
          system: systemMetrics,
          index: indexStats
        }
      }
    } catch (error) {
      return {
        success: false,
        error: 'Failed to get metrics',
        message: String(error)
      }
    }
  }, {
    detail: {
      tags: ['RAG System'],
      summary: 'System metrics',
      description: 'Get RAG system performance metrics and statistics'
    }
  })
)

// ============================================================================
// Dual-Database Information (Simple & Essential)
// ============================================================================

// Simple dual-database documentation and status
app.group('/v1/database', (app) => app
  .get('/', () => ({
    title: 'Dual-Database RAG Architecture',
    description: 'PostgreSQL + pgvector and Neo4j for optimized retrieval',
    architecture: {
      postgresql: {
        role: 'Vector similarity and traditional queries',
        features: ['pgvector', 'semantic_search', 'full_text_search']
      },
      neo4j: {
        role: 'Graph relationships and traversal', 
        features: ['graph_traversal', 'relationship_analysis', 'centrality_metrics']
      },
      router: {
        description: 'Intelligent query routing based on characteristics',
        strategies: ['vector_first', 'graph_first', 'adaptive']
      }
    },
    usage: {
      semantic_search: 'Routes to PostgreSQL for vector similarity',
      entity_relationships: 'Routes to Neo4j for graph traversal',
      hybrid_queries: 'Uses both databases for optimal results'
    }
  }), {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Dual-database architecture overview',
      description: 'Overview of the dual-database system design and routing capabilities'
    }
  })

  .get('/status', () => ({
    success: true,
    postgresql: { 
      status: 'healthy', 
      schemas: ['public', 'graph_public'],
      features: ['pgvector', 'semantic_search', 'dual_schema']
    },
    neo4j: { 
      status: 'healthy', 
      nodeTypes: ['Document', 'Chunk', 'Entity'],
      features: ['graph_traversal', 'relationship_analysis']
    },
    router: { 
      strategy: 'adaptive', 
      status: 'active',
      description: 'Automatically selects optimal database per query'
    },
    sync: { 
      status: 'synchronized', 
      strategy: 'bidirectional',
      lastSync: new Date().toISOString() 
    }
  }), {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Database system status',
      description: 'Current status of PostgreSQL, Neo4j, routing, and synchronization'
    }
  })
)

// Helper functions for dual-database simulation

  // Synchronization status and controls
  .get('/sync', () => ({
    success: true,
    data: {
      status: 'synchronized',
      strategy: 'bidirectional',
      lastSync: new Date().toISOString(),
      syncFrequency: '5 minutes',
      statistics: {
        documentsSync: 1247,
        entitiesSync: 856,
        relationshipsSync: 2103,
        conflictsResolved: 3,
        lastConflictTime: '2025-08-30T14:23:00Z'
      },
      health: {
        postgresqlReplication: 'healthy',
        neo4jSync: 'healthy',
        conflictResolution: 'automatic',
        auditLog: 'active'
      },
      configuration: {
        conflictResolution: 'latest_timestamp',
        batchSize: 100,
        retryAttempts: 3,
        syncTimeout: '30s'
      }
    }
  }), {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Synchronization status',
      description: 'Get database synchronization status and configuration'
    }
  })

  // Graph analytics and metrics
  .get('/analytics', () => ({
    success: true,
    data: {
      graphMetrics: {
        nodes: {
          total: 2847,
          types: {
            Document: 1247,
            Chunk: 856,
            Entity: 523,
            Concept: 156,
            Topic: 65
          }
        },
        relationships: {
          total: 5692,
          types: {
            CONTAINS: 2103,
            MENTIONS: 1456,
            RELATED_TO: 1234,
            PART_OF: 567,
            CITES: 332
          }
        },
        centrality: {
          topNodes: [
            { id: 'ai-concepts', type: 'Concept', pageRank: 0.156, betweenness: 0.234 },
            { id: 'machine-learning', type: 'Topic', pageRank: 0.143, betweenness: 0.198 },
            { id: 'neural-networks', type: 'Concept', pageRank: 0.128, betweenness: 0.176 }
          ]
        },
        communities: {
          count: 23,
          largestCommunity: 156,
          modularity: 0.8234
        }
      },
      queryMetrics: {
        avgResponseTime: {
          postgresql: '12ms',
          neo4j: '8ms',
          hybrid: '18ms'
        },
        queryTypes: {
          semantic_search: { count: 1456, avgTime: '11ms', database: 'postgresql' },
          graph_traversal: { count: 892, avgTime: '9ms', database: 'neo4j' },
          entity_lookup: { count: 2341, avgTime: '6ms', database: 'adaptive' },
          analytics: { count: 156, avgTime: '45ms', database: 'neo4j' }
        }
      }
    }
  }), {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Database analytics',
      description: 'Get comprehensive analytics including graph metrics and query performance'
    }
  })

  // Performance monitoring
  .get('/performance', () => ({
    success: true,
    data: {
      realTime: {
        postgresql: {
          activeConnections: 12,
          queryQueueLength: 0,
          avgResponseTime: '12ms',
          cacheHitRate: '94%',
          indexEfficiency: '96%'
        },
        neo4j: {
          activeConnections: 8,
          queryQueueLength: 0,
          avgResponseTime: '8ms',
          cacheHitRate: '91%',
          memoryUsage: '67%'
        },
        router: {
          routingDecisions: 23,
          cacheHits: 20,
          fallbacks: 0,
          avgRoutingTime: '0.8ms'
        }
      },
      trends: {
        last24Hours: {
          totalQueries: 15234,
          routingDistribution: {
            postgresql: 8567,
            neo4j: 4892,
            hybrid: 1775
          },
          avgResponseTimes: [
            { hour: 0, postgresql: 11, neo4j: 7, hybrid: 17 },
            { hour: 1, postgresql: 12, neo4j: 8, hybrid: 18 },
            { hour: 2, postgresql: 10, neo4j: 6, hybrid: 16 }
          ]
        }
      },
      alerts: []
    }
  }), {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Performance monitoring',
      description: 'Real-time performance metrics and trends for both databases'
    }
  })

  // Enhanced RAG queries using dual-database
  .post('/query', async ({ body }: any) => {
    try {
      const { query, queryType, useGraphEnhancement, maxGraphDepth } = body
      
      if (!query) {
        return {
          success: false,
          error: 'Missing query parameter',
          message: 'Query text is required'
        }
      }

      // Simulate intelligent routing decision
      const routingDecision = determineRoutingStrategy(query, queryType)
      
      return {
        success: true,
        data: {
          query,
          routing: routingDecision,
          results: await simulateQueryResults(query, routingDecision),
          enhancement: useGraphEnhancement ? await simulateGraphEnhancement(query, maxGraphDepth) : null,
          performance: {
            totalTime: '24ms',
            databaseTime: routingDecision.primaryDatabase === 'postgresql' ? '12ms' : '8ms',
            enhancementTime: useGraphEnhancement ? '12ms' : '0ms'
          }
        }
      }
    } catch (error) {
      return {
        success: false,
        error: 'Dual-database query failed',
        message: String(error)
      }
    }
  }, {
    detail: {
      tags: ['Dual-Database'],
      summary: 'Enhanced dual-database query',
      description: 'Execute queries using the dual-database system with intelligent routing and optional graph enhancement',
      body: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query text' },
          queryType: { 
            type: 'string', 
            enum: ['semantic_search', 'entity_lookup', 'relationship_traversal', 'graph_analytics', 'hybrid'],
            description: 'Type of query to help with routing decisions'
          },
          useGraphEnhancement: { type: 'boolean', default: false, description: 'Enable graph-based result enhancement' },
          maxGraphDepth: { type: 'integer', minimum: 1, maximum: 5, default: 2, description: 'Maximum graph traversal depth for enhancement' }
        },
        required: ['query']
      }
    }
  })
)

// Helper functions for dual-database simulation
function determineRoutingStrategy(query: string, queryType?: string) {
  // Simplified routing logic for demonstration
  if (queryType === 'graph_analytics' || queryType === 'relationship_traversal') {
    return {
      strategy: 'graph_first',
      primaryDatabase: 'neo4j',
      secondaryDatabase: 'postgresql',
      reasoning: 'Graph operations benefit from Neo4j\'s native graph capabilities'
    }
  }
  
  if (queryType === 'semantic_search' || query.includes('similar') || query.includes('like')) {
    return {
      strategy: 'vector_first',
      primaryDatabase: 'postgresql',
      secondaryDatabase: 'neo4j',
      reasoning: 'Semantic similarity search optimized for pgvector'
    }
  }
  
  return {
    strategy: 'adaptive',
    primaryDatabase: 'postgresql',
    secondaryDatabase: 'neo4j',
    reasoning: 'Adaptive strategy selected based on query characteristics'
  }
}

async function simulateQueryResults(query: string, routing: any) {
  // Simulate database-specific results
  return {
    documents: [
      {
        id: 'doc_1',
        title: `Relevant document for: ${query}`,
        content: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit...',
        score: 0.89,
        database: routing.primaryDatabase,
        metadata: {
          source: 'academic_paper',
          date: '2025-08-15',
          author: 'Dr. Smith'
        }
      },
      {
        id: 'doc_2',
        title: `Secondary match for: ${query}`,
        content: 'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua...',
        score: 0.76,
        database: routing.primaryDatabase,
        metadata: {
          source: 'blog_post',
          date: '2025-08-20',
          author: 'Tech Blogger'
        }
      }
    ],
    totalFound: 156,
    queryTime: routing.primaryDatabase === 'postgresql' ? '12ms' : '8ms'
  }
}

async function simulateGraphEnhancement(query: string, maxDepth: number = 2) {
  // Simulate graph-based enhancement
  return {
    relatedEntities: [
      { id: 'entity_1', name: 'Machine Learning', type: 'Concept', relevance: 0.92 },
      { id: 'entity_2', name: 'Neural Networks', type: 'Technology', relevance: 0.87 },
      { id: 'entity_3', name: 'Data Science', type: 'Field', relevance: 0.81 }
    ],
    relationships: [
      { from: 'entity_1', to: 'entity_2', type: 'IMPLEMENTS', strength: 0.89 },
      { from: 'entity_1', to: 'entity_3', type: 'PART_OF', strength: 0.76 }
    ],
    graphMetrics: {
      traversalDepth: maxDepth,
      nodesExplored: 23,
      pathsFound: 7,
      centralityScore: 0.156
    }
  }
}

// ============================================================================
// WebSocket Interface
// ============================================================================

interface ClientData {
  clientId: string
  joinedAt: string
  userId?: string
}

interface ParsedMessage {
  type?: string
  userId?: string
  text?: string
  [key: string]: unknown
}

// ============================================================================
// Main Server Function
// ============================================================================

async function startServer() {
  // Build client if not in test environment
  if (config.environment !== 'test') {
    try {
      console.log('üî® Building client assets...')
      await buildClient()
    } catch (error) {
      console.error('‚ùå Client build failed:', error)
      process.exit(1)
    }
  }

  // Initialize RAG System
  try {
    console.log('üß† Initializing RAG system...')
    ragService = await bootstrapRagSystemWithValidation({
      databaseUrl: process.env.DATABASE_URL,
      embeddingModel: 'all-MiniLM-L6-v2',
      defaultStrategy: 'retrieve_read',
      defaultTopK: 5,
      scoreThreshold: 0.5
    })
    console.log('‚úÖ RAG system initialized successfully')
  } catch (error) {
    console.warn('‚ö†Ô∏è  RAG system initialization failed:', error)
    console.warn('üîß RAG endpoints will be disabled. Check DATABASE_URL and dependencies.')
    // Continue without RAG system - server can still function
  }

  const serverOptions = {
    async fetch(req: Request, server: Server): Promise<Response> {
      const url = new URL(req.url)

      // WebSocket upgrade endpoint
      if (url.pathname === '/webhooks/ws') {
        const upgraded = server.upgrade<ClientData>(req, {
          data: {
            clientId: crypto.randomUUID(),
            joinedAt: new Date().toISOString(),
          },
        })

        if (!upgraded) {
          return new Response('WebSocket upgrade failed', { status: 400 })
        }

        return new Response()
      }

      // Reverse proxy: /docs -> /swagger
      if (url.pathname === '/docs') {
        const swaggerUrl = new URL(req.url)
        swaggerUrl.pathname = '/swagger'
        const swaggerRequest = new Request(swaggerUrl, req)
        return await app.handle(swaggerRequest)
      }

      // Serve static files from /public
      if (url.pathname.startsWith('/public/') || url.pathname === '/favicon.ico') {
        const publicPath = join(process.cwd(), 'public', url.pathname.replace('/public/', ''))
        if (existsSync(publicPath)) {
          const file = Bun.file(publicPath)
          return new Response(file)
        }
      }

      // Serve client JavaScript files
      if (url.pathname.startsWith('/client') && url.pathname.endsWith('.js')) {
        try {
          const requestedFile = url.pathname.replace(/^\/+/, '')
          const publicDir = join(process.cwd(), 'public')
          const specificFilePath = join(publicDir, requestedFile)

          // Security: Reject path traversal attempts
          if (!specificFilePath.startsWith(publicDir)) {
            return new Response('Forbidden', { status: 403 })
          }

          if (existsSync(specificFilePath)) {
            const file = Bun.file(specificFilePath)
            return new Response(file, {
              headers: {
                'Content-Type': 'application/javascript',
                'Cache-Control': 'max-age=3600',
              },
            })
          }

          // Fallback to current client file
          const currentClientJs = getClientFilename()
          const filePath = join(publicDir, currentClientJs)
          if (existsSync(filePath)) {
            const file = Bun.file(filePath)
            return new Response(file, {
              headers: {
                'Content-Type': 'application/javascript',
                'Cache-Control': 'max-age=3600',
              },
            })
          }

          return new Response('Client file not found', { status: 404 })
        } catch (error) {
          console.error('Error serving client file:', error)
          return new Response('File not found', { status: 404 })
        }
      }

      // Handle all other requests through Elysia
      try {
        return await app.handle(req)
      } catch (error) {
        console.error('Elysia handler error:', error)
        return new Response('Internal Server Error', { status: 500 })
      }
    },
    
    websocket: {
      open(ws: ServerWebSocket<ClientData>) {
        console.log(`WebSocket connection opened: ${ws.data.clientId}`)
        ws.send(JSON.stringify({
          type: 'connection',
          message: 'Connected to AI Agents Server',
          clientId: ws.data.clientId
        }))
      },
      
      message(ws: ServerWebSocket<ClientData>, message: string) {
        try {
          const parsedMessage = JSON.parse(message) as ParsedMessage
          
          if (parsedMessage.type === 'subscribe' && parsedMessage.userId) {
            ws.data.userId = parsedMessage.userId
            ws.send(JSON.stringify({
              type: 'subscribed',
              message: `Subscribed to events for user ${parsedMessage.userId}`
            }))
          } else if (parsedMessage.type === 'ping') {
            ws.send(JSON.stringify({
              type: 'pong',
              timestamp: Date.now()
            }))
          } else {
            ws.send(JSON.stringify({
              type: 'error',
              message: 'Invalid message format'
            }))
          }
        } catch (error) {
          console.error('Error parsing WebSocket message:', error)
          ws.send(JSON.stringify({
            type: 'error',
            message: 'Invalid message format'
          }))
        }
      },
      
      close(ws: ServerWebSocket<ClientData>) {
        console.log(`WebSocket connection closed: ${ws.data.clientId}`)
      },
    },
    
    port: config.port,
    hostname: '0.0.0.0', // Bind to all interfaces
    development: config.environment === 'development',
  } as const

  const server = serve(serverOptions)
  
  console.log('üöÄ AI Agents Server is starting up...')
  console.log(`üì° Server running at http://localhost:${server.port}`)
  console.log(`üè† Dashboard available at http://localhost:${server.port}/`)
  console.log(`üìö API documentation available at http://localhost:${server.port}/docs`)
  console.log(`üîó WebSocket endpoint: ws://localhost:${server.port}/webhooks/ws`)
  console.log(`üåê Accessible externally at http://<your-ip>:${server.port}/`)
  
  if (config.openai.apiKey) {
    console.log('‚úÖ OpenAI integration enabled')
  } else {
    console.log('‚ö†Ô∏è  OpenAI integration disabled (no API key provided)')
  }
  
  if (ragService) {
    console.log('‚úÖ Dual-database RAG system enabled (PostgreSQL + Neo4j)')
    console.log(`üß† RAG endpoints available at http://localhost:${server.port}/v1/rag/*`)
    console.log(`üóÑÔ∏è  Database monitoring at http://localhost:${server.port}/v1/database/*`)
    console.log('   ‚Ä¢ PostgreSQL with pgvector for semantic search')
    console.log('   ‚Ä¢ Neo4j for graph relationships and analytics')
    console.log('   ‚Ä¢ Intelligent routing with adaptive strategies')
  } else {
    console.log('‚ö†Ô∏è  RAG system disabled (initialization failed)')
  }
  
  console.log('üü¢ Server ready to accept connections!')
  
  return server
}

// Start server if not in test environment
if (config.environment !== 'test') {
  startServer().catch((error) => {
    console.error('Failed to start server:', error)
    process.exit(1)
  })
}

export { startServer, app }
